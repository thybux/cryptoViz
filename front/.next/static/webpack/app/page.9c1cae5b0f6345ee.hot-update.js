"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/components/Chart.tsx":
/*!**********************************!*\
  !*** ./app/components/Chart.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _context_CryptoContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../context/CryptoContext */ \"(app-pages-browser)/./app/context/CryptoContext.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\nconst timeframes = {\n    \"1m\": \"1\",\n    \"5m\": \"5\",\n    \"15m\": \"15\",\n    \"1h\": \"60\"\n};\n// Configurations des indicateurs\nconst indicators = {\n    MA: {\n        periods: [\n            20,\n            50,\n            200\n        ],\n        colors: [\n            \"#ff6b6b\",\n            \"#4ecdc4\",\n            \"#45b7d1\"\n        ]\n    },\n    Bollinger: {\n        period: 20,\n        stdDev: 2,\n        color: \"#9775fa\"\n    }\n};\n// Récupérer le dernier prix\nconst latestPrice = async (crypto)=>{\n    let result = await fetch(\"http://10.18.206.239:6060/crypto/latest/\" + crypto);\n    let data = await result.json();\n    data.ohlc.time = new Date(data.timestamp).getTime() / 1000;\n    const newCandle = data.ohlc;\n    return newCandle;\n};\n// Récupérer les données historiques\nconst historyPrice = async (crypto, timeframe)=>{\n    let result = await fetch(\"http://10.18.206.239:6060/crypto/history/\".concat(crypto, \"?timeframe=\").concat(timeframe));\n    let data = await result.json();\n    return data.history.map((candle)=>({\n            time: new Date(candle.timestamp).getTime() / 1000,\n            open: candle.ohlc.open,\n            high: candle.ohlc.high,\n            low: candle.ohlc.low,\n            close: candle.ohlc.close\n        }));\n};\n// Calculer la moyenne mobile (MA)\nconst calculateMA = (data, period)=>{\n    const maData = [];\n    for(let i = 0; i < data.length; i++){\n        if (i < period - 1) {\n            maData.push({\n                time: data[i].time,\n                value: NaN\n            });\n            continue;\n        }\n        const slice = data.slice(i - period + 1, i + 1);\n        const sum = slice.reduce((acc, curr)=>acc + curr.close, 0);\n        const ma = sum / period;\n        maData.push({\n            time: data[i].time,\n            value: ma\n        });\n    }\n    return maData;\n};\n// Calculer les bandes de Bollinger\nconst calculateBollingerBands = (data, period, stdDevFactor)=>{\n    const maData = calculateMA(data, period);\n    const bands = {\n        middle: maData,\n        upper: [],\n        lower: []\n    };\n    for(let i = 0; i < data.length; i++){\n        if (i < period - 1) {\n            bands.upper.push({\n                time: data[i].time,\n                value: NaN\n            });\n            bands.lower.push({\n                time: data[i].time,\n                value: NaN\n            });\n            continue;\n        }\n        const slice = data.slice(i - period + 1, i + 1);\n        const mean = maData[i].value;\n        const variance = slice.reduce((acc, curr)=>acc + Math.pow(curr.close - mean, 2), 0) / period;\n        const stdDev = Math.sqrt(variance);\n        bands.upper.push({\n            time: data[i].time,\n            value: mean + stdDevFactor * stdDev\n        });\n        bands.lower.push({\n            time: data[i].time,\n            value: mean - stdDevFactor * stdDev\n        });\n    }\n    return bands;\n};\nconst ChartComponent = ()=>{\n    _s();\n    let { symbol } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_context_CryptoContext__WEBPACK_IMPORTED_MODULE_3__.CryptoContext);\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const seriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const maSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const bollingerSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        upper: null,\n        middle: null,\n        lower: null\n    });\n    const [selectedTimeframe, setSelectedTimeframe] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"1m\");\n    const [showMA, setShowMA] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBollinger, setShowBollinger] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Fonction pour mettre à jour une bougie existante\n    const updateCandle = (candle, newValue)=>({\n            time: candle.time,\n            close: newValue,\n            open: candle.open,\n            low: Math.min(candle.low, newValue),\n            high: Math.max(candle.high, newValue)\n        });\n    const initializeChart = async (crypto)=>{\n        var _seriesRef_current, _chartRef_current;\n        const historicalData = await historyPrice(crypto, selectedTimeframe);\n        (_seriesRef_current = seriesRef.current) === null || _seriesRef_current === void 0 ? void 0 : _seriesRef_current.setData(historicalData);\n        console.log(\"before\", crypto);\n        // Mettre à jour les indicateurs\n        if (showMA) {\n            indicators.MA.periods.forEach((period, index)=>{\n                var _maSeriesRefs_current_index;\n                const maData = calculateMA(historicalData, period);\n                (_maSeriesRefs_current_index = maSeriesRefs.current[index]) === null || _maSeriesRefs_current_index === void 0 ? void 0 : _maSeriesRefs_current_index.setData(maData);\n            });\n        }\n        if (showBollinger) {\n            var _bollingerSeriesRefs_current_upper, _bollingerSeriesRefs_current_middle, _bollingerSeriesRefs_current_lower;\n            const bollingerData = calculateBollingerBands(historicalData, indicators.Bollinger.period, indicators.Bollinger.stdDev);\n            (_bollingerSeriesRefs_current_upper = bollingerSeriesRefs.current.upper) === null || _bollingerSeriesRefs_current_upper === void 0 ? void 0 : _bollingerSeriesRefs_current_upper.setData(bollingerData.upper);\n            (_bollingerSeriesRefs_current_middle = bollingerSeriesRefs.current.middle) === null || _bollingerSeriesRefs_current_middle === void 0 ? void 0 : _bollingerSeriesRefs_current_middle.setData(bollingerData.middle);\n            (_bollingerSeriesRefs_current_lower = bollingerSeriesRefs.current.lower) === null || _bollingerSeriesRefs_current_lower === void 0 ? void 0 : _bollingerSeriesRefs_current_lower.setData(bollingerData.lower);\n        }\n        (_chartRef_current = chartRef.current) === null || _chartRef_current === void 0 ? void 0 : _chartRef_current.timeScale().fitContent();\n        let count = 0;\n        let currentCrypto = crypto;\n        // Gérer les mises à jour en temps réel\n        const intervalId = setInterval(async ()=>{\n            count++;\n            const latestCandle = await latestPrice(crypto);\n            const historicalData2 = await historyPrice(crypto, selectedTimeframe);\n            const lastCandle = historicalData2[historicalData.length - 1];\n            if (count < 5) {\n                // Mettre à jour la dernière bougie\n                const updatedCandle = updateCandle(lastCandle, latestCandle.close);\n                // console.log(updatedCandle);\n                try {\n                    var _seriesRef_current;\n                    (_seriesRef_current = seriesRef.current) === null || _seriesRef_current === void 0 ? void 0 : _seriesRef_current.update(updatedCandle);\n                } catch (error) {\n                    console.log(error);\n                }\n                console.log(\"if count\", currentCrypto);\n            } else {\n                var _seriesRef_current1;\n                // Ajouter une nouvelle bougie\n                console.log(\"else\", currentCrypto);\n                (_seriesRef_current1 = seriesRef.current) === null || _seriesRef_current1 === void 0 ? void 0 : _seriesRef_current1.update(latestCandle);\n                historicalData.push(latestCandle);\n                count = 0;\n            }\n            // Mettre à jour les indicateurs\n            if (showMA) {\n                indicators.MA.periods.forEach((period, index)=>{\n                    var _maSeriesRefs_current_index;\n                    const maData = calculateMA(historicalData, period);\n                    (_maSeriesRefs_current_index = maSeriesRefs.current[index]) === null || _maSeriesRefs_current_index === void 0 ? void 0 : _maSeriesRefs_current_index.setData(maData);\n                });\n            }\n            if (showBollinger) {\n                var _bollingerSeriesRefs_current_upper, _bollingerSeriesRefs_current_middle, _bollingerSeriesRefs_current_lower;\n                const bollingerData = calculateBollingerBands(historicalData, indicators.Bollinger.period, indicators.Bollinger.stdDev);\n                (_bollingerSeriesRefs_current_upper = bollingerSeriesRefs.current.upper) === null || _bollingerSeriesRefs_current_upper === void 0 ? void 0 : _bollingerSeriesRefs_current_upper.setData(bollingerData.upper);\n                (_bollingerSeriesRefs_current_middle = bollingerSeriesRefs.current.middle) === null || _bollingerSeriesRefs_current_middle === void 0 ? void 0 : _bollingerSeriesRefs_current_middle.setData(bollingerData.middle);\n                (_bollingerSeriesRefs_current_lower = bollingerSeriesRefs.current.lower) === null || _bollingerSeriesRefs_current_lower === void 0 ? void 0 : _bollingerSeriesRefs_current_lower.setData(bollingerData.lower);\n            }\n        }, 10000); // Mise à jour toutes les 10 secondes\n        console.log(\"after\", crypto);\n        return ()=>clearInterval(intervalId);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        const chartOptions = {\n            layout: {\n                textColor: \"black\",\n                background: {\n                    type: \"solid\",\n                    color: \"white\"\n                }\n            },\n            height: 500,\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, chartOptions);\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: true,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        chartRef.current = chart;\n        seriesRef.current = candlestickSeries;\n        // Initialiser les séries MA\n        maSeriesRefs.current = indicators.MA.periods.map((period, index)=>chart.addLineSeries({\n                color: indicators.MA.colors[index],\n                lineWidth: 2,\n                visible: showMA\n            }));\n        // Initialiser les séries Bollinger\n        const bollingerUpper = chart.addLineSeries({\n            color: indicators.Bollinger.color,\n            lineWidth: 1,\n            lineStyle: 2,\n            visible: showBollinger\n        });\n        const bollingerMiddle = chart.addLineSeries({\n            color: indicators.Bollinger.color,\n            lineWidth: 2,\n            visible: showBollinger\n        });\n        const bollingerLower = chart.addLineSeries({\n            color: indicators.Bollinger.color,\n            lineWidth: 1,\n            lineStyle: 2,\n            visible: showBollinger\n        });\n        bollingerSeriesRefs.current = {\n            upper: bollingerUpper,\n            middle: bollingerMiddle,\n            lower: bollingerLower\n        };\n        return ()=>{\n            chart.remove();\n        };\n    }, [\n        symbol\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartRef.current || !seriesRef.current) return;\n        initializeChart(symbol);\n    }, [\n        selectedTimeframe,\n        showMA,\n        showBollinger,\n        symbol\n    ]);\n    // Gérer la visibilité des MA\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        maSeriesRefs.current.forEach((series)=>{\n            series === null || series === void 0 ? void 0 : series.applyOptions({\n                visible: showMA\n            });\n        });\n    }, [\n        showMA\n    ]);\n    // Gérer la visibilité des Bollinger Bands\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        Object.values(bollingerSeriesRefs.current).forEach((series)=>{\n            series === null || series === void 0 ? void 0 : series.applyOptions({\n                visible: showBollinger\n            });\n        });\n    }, [\n        showBollinger,\n        symbol\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: styles.controlsContainer,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: styles.timeframeContainer,\n                        children: Object.keys(timeframes).map((tf, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                style: {\n                                    ...styles.button,\n                                    backgroundColor: selectedTimeframe === tf ? \"#ddd\" : \"#fff\"\n                                },\n                                onClick: ()=>setSelectedTimeframe(tf),\n                                children: tf\n                            }, index, false, {\n                                fileName: \"/Users/jeremyjoseph/Epitech/cryptoWiz/front/app/components/Chart.tsx\",\n                                lineNumber: 312,\n                                columnNumber: 25\n                            }, undefined))\n                    }, void 0, false, {\n                        fileName: \"/Users/jeremyjoseph/Epitech/cryptoWiz/front/app/components/Chart.tsx\",\n                        lineNumber: 310,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: styles.indicatorsContainer,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                style: {\n                                    ...styles.button,\n                                    backgroundColor: showMA ? \"#ddd\" : \"#fff\"\n                                },\n                                onClick: ()=>setShowMA(!showMA),\n                                children: \"MA\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jeremyjoseph/Epitech/cryptoWiz/front/app/components/Chart.tsx\",\n                                lineNumber: 325,\n                                columnNumber: 21\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                style: {\n                                    ...styles.button,\n                                    backgroundColor: showBollinger ? \"#ddd\" : \"#fff\"\n                                },\n                                onClick: ()=>setShowBollinger(!showBollinger),\n                                children: \"Bollinger\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jeremyjoseph/Epitech/cryptoWiz/front/app/components/Chart.tsx\",\n                                lineNumber: 334,\n                                columnNumber: 21\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jeremyjoseph/Epitech/cryptoWiz/front/app/components/Chart.tsx\",\n                        lineNumber: 324,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jeremyjoseph/Epitech/cryptoWiz/front/app/components/Chart.tsx\",\n                lineNumber: 309,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: chartContainerRef,\n                style: {\n                    position: \"relative\",\n                    width: \"100%\",\n                    height: \"400px\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/jeremyjoseph/Epitech/cryptoWiz/front/app/components/Chart.tsx\",\n                lineNumber: 345,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jeremyjoseph/Epitech/cryptoWiz/front/app/components/Chart.tsx\",\n        lineNumber: 308,\n        columnNumber: 9\n    }, undefined);\n};\n_s(ChartComponent, \"vFfURcfLRaqIEJ7DtwgTckQmyjI=\");\n_c = ChartComponent;\nconst styles = {\n    controlsContainer: {\n        display: \"flex\",\n        justifyContent: \"space-between\",\n        alignItems: \"center\",\n        marginBottom: \"10px\"\n    },\n    timeframeContainer: {\n        display: \"flex\",\n        gap: \"5px\"\n    },\n    indicatorsContainer: {\n        display: \"flex\",\n        gap: \"5px\"\n    },\n    button: {\n        padding: \"8px 16px\",\n        fontWeight: \"bold\",\n        cursor: \"pointer\",\n        borderRadius: \"5px\",\n        border: \"1px solid #ddd\",\n        backgroundColor: \"white\"\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ChartComponent);\nvar _c;\n$RefreshReg$(_c, \"ChartComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0NoYXJ0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1RTtBQUN3QztBQUN0RDtBQVV6RCxNQUFNTyxhQUFhO0lBQ2YsTUFBTTtJQUNOLE1BQU07SUFDTixPQUFPO0lBQ1AsTUFBTTtBQUNWO0FBRUEsaUNBQWlDO0FBQ2pDLE1BQU1DLGFBQWE7SUFDZkMsSUFBSTtRQUNBQyxTQUFTO1lBQUM7WUFBSTtZQUFJO1NBQUk7UUFDdEJDLFFBQVE7WUFBQztZQUFXO1lBQVc7U0FBVTtJQUM3QztJQUNBQyxXQUFXO1FBQ1BDLFFBQVE7UUFDUkMsUUFBUTtRQUNSQyxPQUFPO0lBQ1g7QUFDSjtBQUVBLDRCQUE0QjtBQUM1QixNQUFNQyxjQUFjLE9BQU9DO0lBQ3ZCLElBQUlDLFNBQVMsTUFBTUMsTUFBTSw2Q0FBNkNGO0lBQ3RFLElBQUlHLE9BQU8sTUFBTUYsT0FBT0csSUFBSTtJQUM1QkQsS0FBS0UsSUFBSSxDQUFDQyxJQUFJLEdBQUksSUFBSUMsS0FBS0osS0FBS0ssU0FBUyxFQUFFQyxPQUFPLEtBQUs7SUFDdkQsTUFBTUMsWUFBb0JQLEtBQUtFLElBQUk7SUFDbkMsT0FBT0s7QUFDWDtBQUVBLG9DQUFvQztBQUNwQyxNQUFNQyxlQUFlLE9BQU9YLFFBQWdCWTtJQUN4QyxJQUFJWCxTQUFTLE1BQU1DLE1BQU0sNENBQWdFVSxPQUFwQlosUUFBTyxlQUF1QixPQUFWWTtJQUN6RixJQUFJVCxPQUFPLE1BQU1GLE9BQU9HLElBQUk7SUFDNUIsT0FBT0QsS0FBS1UsT0FBTyxDQUFDQyxHQUFHLENBQUMsQ0FBQ0MsU0FBaUI7WUFDdENULE1BQU8sSUFBSUMsS0FBS1EsT0FBT1AsU0FBUyxFQUFFQyxPQUFPLEtBQUs7WUFDOUNPLE1BQU1ELE9BQU9WLElBQUksQ0FBQ1csSUFBSTtZQUN0QkMsTUFBTUYsT0FBT1YsSUFBSSxDQUFDWSxJQUFJO1lBQ3RCQyxLQUFLSCxPQUFPVixJQUFJLENBQUNhLEdBQUc7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LElBQU1qRSxVQUFVLENBQUNEOzBDQUM3Qjs7Ozs7OzBDQUdELDhEQUFDZ0U7Z0NBQ0dOLE9BQU87b0NBQ0gsR0FBR0MsT0FBT0ssTUFBTTtvQ0FDaEJDLGlCQUFpQi9ELGdCQUFnQixTQUFTO2dDQUM5QztnQ0FDQWdFLFNBQVMsSUFBTS9ELGlCQUFpQixDQUFDRDswQ0FDcEM7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFLVCw4REFBQ3VEO2dCQUFJVyxLQUFLM0U7Z0JBQW1CaUUsT0FBTztvQkFBRVcsVUFBVTtvQkFBWUMsT0FBTztvQkFBUW5DLFFBQVE7Z0JBQVE7Ozs7Ozs7Ozs7OztBQUd2RztHQXpQTTVDO0tBQUFBO0FBMlBOLE1BQU1vRSxTQUFpRDtJQUNuREMsbUJBQW1CO1FBQ2ZXLFNBQVM7UUFDVEMsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pDLGNBQWM7SUFDbEI7SUFDQWIsb0JBQW9CO1FBQ2hCVSxTQUFTO1FBQ1RJLEtBQUs7SUFDVDtJQUNBUixxQkFBcUI7UUFDakJJLFNBQVM7UUFDVEksS0FBSztJQUNUO0lBQ0FYLFFBQVE7UUFDSlksU0FBUztRQUNUQyxZQUFZO1FBQ1pDLFFBQVE7UUFDUkMsY0FBYztRQUNkQyxRQUFRO1FBQ1JmLGlCQUFpQjtJQUNyQjtBQUNKO0FBRUEsK0RBQWUxRSxjQUFjQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb21wb25lbnRzL0NoYXJ0LnRzeD84ODc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVDaGFydCwgSUNoYXJ0QXBpLCBDYW5kbGVzdGlja1Nlcmllc0FwaSwgTGluZVNlcmllc0FwaSwgVVRDVGltZXN0YW1wIH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbmltcG9ydCB7IENyeXB0b0NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L0NyeXB0b0NvbnRleHQnO1xuXG5pbnRlcmZhY2UgQ2FuZGxlIHtcbiAgICB0aW1lOiBVVENUaW1lc3RhbXA7XG4gICAgb3BlbjogbnVtYmVyO1xuICAgIGhpZ2g6IG51bWJlcjtcbiAgICBsb3c6IG51bWJlcjtcbiAgICBjbG9zZTogbnVtYmVyO1xufVxuXG5jb25zdCB0aW1lZnJhbWVzID0ge1xuICAgICcxbSc6ICcxJyxcbiAgICAnNW0nOiAnNScsXG4gICAgJzE1bSc6ICcxNScsXG4gICAgJzFoJzogJzYwJyxcbn07XG5cbi8vIENvbmZpZ3VyYXRpb25zIGRlcyBpbmRpY2F0ZXVyc1xuY29uc3QgaW5kaWNhdG9ycyA9IHtcbiAgICBNQToge1xuICAgICAgICBwZXJpb2RzOiBbMjAsIDUwLCAyMDBdLFxuICAgICAgICBjb2xvcnM6IFsnI2ZmNmI2YicsICcjNGVjZGM0JywgJyM0NWI3ZDEnXSxcbiAgICB9LFxuICAgIEJvbGxpbmdlcjoge1xuICAgICAgICBwZXJpb2Q6IDIwLFxuICAgICAgICBzdGREZXY6IDIsXG4gICAgICAgIGNvbG9yOiAnIzk3NzVmYScsXG4gICAgfSxcbn07XG5cbi8vIFLDqWN1cMOpcmVyIGxlIGRlcm5pZXIgcHJpeFxuY29uc3QgbGF0ZXN0UHJpY2UgPSBhc3luYyAoY3J5cHRvOiBzdHJpbmcpID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly8xMC4xOC4yMDYuMjM5OjYwNjAvY3J5cHRvL2xhdGVzdC8nICsgY3J5cHRvKTtcbiAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgZGF0YS5vaGxjLnRpbWUgPSAobmV3IERhdGUoZGF0YS50aW1lc3RhbXApLmdldFRpbWUoKSAvIDEwMDApIGFzIFVUQ1RpbWVzdGFtcDtcbiAgICBjb25zdCBuZXdDYW5kbGU6IENhbmRsZSA9IGRhdGEub2hsYztcbiAgICByZXR1cm4gbmV3Q2FuZGxlO1xufTtcblxuLy8gUsOpY3Vww6lyZXIgbGVzIGRvbm7DqWVzIGhpc3RvcmlxdWVzXG5jb25zdCBoaXN0b3J5UHJpY2UgPSBhc3luYyAoY3J5cHRvOiBzdHJpbmcsIHRpbWVmcmFtZTogc3RyaW5nKSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGZldGNoKGBodHRwOi8vMTAuMTguMjA2LjIzOTo2MDYwL2NyeXB0by9oaXN0b3J5LyR7Y3J5cHRvfT90aW1lZnJhbWU9JHt0aW1lZnJhbWV9YCk7XG4gICAgbGV0IGRhdGEgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIHJldHVybiBkYXRhLmhpc3RvcnkubWFwKChjYW5kbGU6IGFueSkgPT4gKHtcbiAgICAgICAgdGltZTogKG5ldyBEYXRlKGNhbmRsZS50aW1lc3RhbXApLmdldFRpbWUoKSAvIDEwMDApIGFzIFVUQ1RpbWVzdGFtcCxcbiAgICAgICAgb3BlbjogY2FuZGxlLm9obGMub3BlbixcbiAgICAgICAgaGlnaDogY2FuZGxlLm9obGMuaGlnaCxcbiAgICAgICAgbG93OiBjYW5kbGUub2hsYy5sb3csXG4gICAgICAgIGNsb3NlOiBjYW5kbGUub2hsYy5jbG9zZSxcbiAgICB9KSk7XG59O1xuXG4vLyBDYWxjdWxlciBsYSBtb3llbm5lIG1vYmlsZSAoTUEpXG5jb25zdCBjYWxjdWxhdGVNQSA9IChkYXRhOiBDYW5kbGVbXSwgcGVyaW9kOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBtYURhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCBwZXJpb2QgLSAxKSB7XG4gICAgICAgICAgICBtYURhdGEucHVzaCh7IHRpbWU6IGRhdGFbaV0udGltZSwgdmFsdWU6IE5hTiB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsaWNlID0gZGF0YS5zbGljZShpIC0gcGVyaW9kICsgMSwgaSArIDEpO1xuICAgICAgICBjb25zdCBzdW0gPSBzbGljZS5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5jbG9zZSwgMCk7XG4gICAgICAgIGNvbnN0IG1hID0gc3VtIC8gcGVyaW9kO1xuICAgICAgICBtYURhdGEucHVzaCh7IHRpbWU6IGRhdGFbaV0udGltZSwgdmFsdWU6IG1hIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFEYXRhO1xufTtcblxuLy8gQ2FsY3VsZXIgbGVzIGJhbmRlcyBkZSBCb2xsaW5nZXJcbmNvbnN0IGNhbGN1bGF0ZUJvbGxpbmdlckJhbmRzID0gKGRhdGE6IENhbmRsZVtdLCBwZXJpb2Q6IG51bWJlciwgc3RkRGV2RmFjdG9yOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBtYURhdGEgPSBjYWxjdWxhdGVNQShkYXRhLCBwZXJpb2QpO1xuICAgIGNvbnN0IGJhbmRzID0ge1xuICAgICAgICBtaWRkbGU6IG1hRGF0YSxcbiAgICAgICAgdXBwZXI6IFtdLFxuICAgICAgICBsb3dlcjogW11cbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgcGVyaW9kIC0gMSkge1xuICAgICAgICAgICAgYmFuZHMudXBwZXIucHVzaCh7IHRpbWU6IGRhdGFbaV0udGltZSwgdmFsdWU6IE5hTiB9KTtcbiAgICAgICAgICAgIGJhbmRzLmxvd2VyLnB1c2goeyB0aW1lOiBkYXRhW2ldLnRpbWUsIHZhbHVlOiBOYU4gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNsaWNlID0gZGF0YS5zbGljZShpIC0gcGVyaW9kICsgMSwgaSArIDEpO1xuICAgICAgICBjb25zdCBtZWFuID0gbWFEYXRhW2ldLnZhbHVlO1xuICAgICAgICBjb25zdCB2YXJpYW5jZSA9IHNsaWNlLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBNYXRoLnBvdyhjdXJyLmNsb3NlIC0gbWVhbiwgMiksIDApIC8gcGVyaW9kO1xuICAgICAgICBjb25zdCBzdGREZXYgPSBNYXRoLnNxcnQodmFyaWFuY2UpO1xuXG4gICAgICAgIGJhbmRzLnVwcGVyLnB1c2goeyB0aW1lOiBkYXRhW2ldLnRpbWUsIHZhbHVlOiBtZWFuICsgc3RkRGV2RmFjdG9yICogc3RkRGV2IH0pO1xuICAgICAgICBiYW5kcy5sb3dlci5wdXNoKHsgdGltZTogZGF0YVtpXS50aW1lLCB2YWx1ZTogbWVhbiAtIHN0ZERldkZhY3RvciAqIHN0ZERldiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFuZHM7XG59O1xuXG5jb25zdCBDaGFydENvbXBvbmVudDogUmVhY3QuRkMgPSAoKSA9PiB7XG4gICAgbGV0IHtzeW1ib2x9ID0gdXNlQ29udGV4dChDcnlwdG9Db250ZXh0KVxuICAgIGNvbnN0IGNoYXJ0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxJQ2hhcnRBcGkgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBzZXJpZXNSZWYgPSB1c2VSZWY8Q2FuZGxlc3RpY2tTZXJpZXNBcGkgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBtYVNlcmllc1JlZnMgPSB1c2VSZWY8TGluZVNlcmllc0FwaVtdPihbXSk7XG4gICAgY29uc3QgYm9sbGluZ2VyU2VyaWVzUmVmcyA9IHVzZVJlZjx7XG4gICAgICAgIHVwcGVyOiBMaW5lU2VyaWVzQXBpIHwgbnVsbDtcbiAgICAgICAgbWlkZGxlOiBMaW5lU2VyaWVzQXBpIHwgbnVsbDtcbiAgICAgICAgbG93ZXI6IExpbmVTZXJpZXNBcGkgfCBudWxsO1xuICAgIH0+KHsgdXBwZXI6IG51bGwsIG1pZGRsZTogbnVsbCwgbG93ZXI6IG51bGwgfSk7XG5cbiAgICBjb25zdCBbc2VsZWN0ZWRUaW1lZnJhbWUsIHNldFNlbGVjdGVkVGltZWZyYW1lXSA9IHVzZVN0YXRlPCcxbScgfCAnNW0nIHwgJzE1bScgfCAnMWgnPignMW0nKTtcbiAgICBjb25zdCBbc2hvd01BLCBzZXRTaG93TUFdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIGNvbnN0IFtzaG93Qm9sbGluZ2VyLCBzZXRTaG93Qm9sbGluZ2VyXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIC8vIEZvbmN0aW9uIHBvdXIgbWV0dHJlIMOgIGpvdXIgdW5lIGJvdWdpZSBleGlzdGFudGVcbiAgICBjb25zdCB1cGRhdGVDYW5kbGUgPSAoY2FuZGxlOiBDYW5kbGUsIG5ld1ZhbHVlOiBudW1iZXIpOiBDYW5kbGUgPT4gKHtcbiAgICAgICAgdGltZTogY2FuZGxlLnRpbWUsXG4gICAgICAgIGNsb3NlOiBuZXdWYWx1ZSxcbiAgICAgICAgb3BlbjogY2FuZGxlLm9wZW4sXG4gICAgICAgIGxvdzogTWF0aC5taW4oY2FuZGxlLmxvdywgbmV3VmFsdWUpLFxuICAgICAgICBoaWdoOiBNYXRoLm1heChjYW5kbGUuaGlnaCwgbmV3VmFsdWUpLFxuICAgIH0pO1xuXG5cblxuXG5cbiAgICBjb25zdCBpbml0aWFsaXplQ2hhcnQgPSBhc3luYyAoY3J5cHRvKSA9PiB7XG4gICAgICAgXG4gICAgICAgIGNvbnN0IGhpc3RvcmljYWxEYXRhID0gYXdhaXQgaGlzdG9yeVByaWNlKGNyeXB0bywgc2VsZWN0ZWRUaW1lZnJhbWUpO1xuICAgICAgICBzZXJpZXNSZWYuY3VycmVudD8uc2V0RGF0YShoaXN0b3JpY2FsRGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYmVmb3JlXCIsIGNyeXB0bylcblxuXG4gICAgICAgIC8vIE1ldHRyZSDDoCBqb3VyIGxlcyBpbmRpY2F0ZXVyc1xuICAgICAgICBpZiAoc2hvd01BKSB7XG4gICAgICAgICAgICBpbmRpY2F0b3JzLk1BLnBlcmlvZHMuZm9yRWFjaCgocGVyaW9kLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hRGF0YSA9IGNhbGN1bGF0ZU1BKGhpc3RvcmljYWxEYXRhLCBwZXJpb2QpO1xuICAgICAgICAgICAgICAgIG1hU2VyaWVzUmVmcy5jdXJyZW50W2luZGV4XT8uc2V0RGF0YShtYURhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvd0JvbGxpbmdlcikge1xuXG4gICAgICAgICAgICBjb25zdCBib2xsaW5nZXJEYXRhID0gY2FsY3VsYXRlQm9sbGluZ2VyQmFuZHMoXG4gICAgICAgICAgICAgICAgaGlzdG9yaWNhbERhdGEsXG4gICAgICAgICAgICAgICAgaW5kaWNhdG9ycy5Cb2xsaW5nZXIucGVyaW9kLFxuICAgICAgICAgICAgICAgIGluZGljYXRvcnMuQm9sbGluZ2VyLnN0ZERldlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYm9sbGluZ2VyU2VyaWVzUmVmcy5jdXJyZW50LnVwcGVyPy5zZXREYXRhKGJvbGxpbmdlckRhdGEudXBwZXIpO1xuICAgICAgICAgICAgYm9sbGluZ2VyU2VyaWVzUmVmcy5jdXJyZW50Lm1pZGRsZT8uc2V0RGF0YShib2xsaW5nZXJEYXRhLm1pZGRsZSk7XG4gICAgICAgICAgICBib2xsaW5nZXJTZXJpZXNSZWZzLmN1cnJlbnQubG93ZXI/LnNldERhdGEoYm9sbGluZ2VyRGF0YS5sb3dlcik7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydFJlZi5jdXJyZW50Py50aW1lU2NhbGUoKS5maXRDb250ZW50KCk7XG4gICAgICAgIGxldCBjb3VudCA9IDBcbiAgICAgICAgbGV0IGN1cnJlbnRDcnlwdG8gPSBjcnlwdG9cbiAgICAgICAgLy8gR8OpcmVyIGxlcyBtaXNlcyDDoCBqb3VyIGVuIHRlbXBzIHLDqWVsXG4gICAgICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb3VudCsrXG4gICAgICAgICAgICBjb25zdCBsYXRlc3RDYW5kbGUgPSBhd2FpdCBsYXRlc3RQcmljZShjcnlwdG8pO1xuICAgICAgICAgICAgY29uc3QgaGlzdG9yaWNhbERhdGEyID0gYXdhaXQgaGlzdG9yeVByaWNlKGNyeXB0bywgc2VsZWN0ZWRUaW1lZnJhbWUpO1xuICAgICAgICAgICAgY29uc3QgbGFzdENhbmRsZSA9IGhpc3RvcmljYWxEYXRhMltoaXN0b3JpY2FsRGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGNvdW50IDwgNSkge1xuICAgICAgICAgICAgICAgIC8vIE1ldHRyZSDDoCBqb3VyIGxhIGRlcm5pw6hyZSBib3VnaWVcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkQ2FuZGxlID0gdXBkYXRlQ2FuZGxlKGxhc3RDYW5kbGUsIGxhdGVzdENhbmRsZS5jbG9zZSk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codXBkYXRlZENhbmRsZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzUmVmLmN1cnJlbnQ/LnVwZGF0ZSh1cGRhdGVkQ2FuZGxlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJpZiBjb3VudFwiLCBjdXJyZW50Q3J5cHRvKVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFqb3V0ZXIgdW5lIG5vdXZlbGxlIGJvdWdpZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZWxzZVwiLCBjdXJyZW50Q3J5cHRvKVxuICAgICAgICAgICAgICAgIHNlcmllc1JlZi5jdXJyZW50Py51cGRhdGUobGF0ZXN0Q2FuZGxlKTtcbiAgICAgICAgICAgICAgICBoaXN0b3JpY2FsRGF0YS5wdXNoKGxhdGVzdENhbmRsZSk7XG4gICAgICAgICAgICAgICAgY291bnQgPSAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgXG5cbiAgICAgICAgICAgIC8vIE1ldHRyZSDDoCBqb3VyIGxlcyBpbmRpY2F0ZXVyc1xuICAgICAgICAgICAgaWYgKHNob3dNQSkge1xuICAgICAgICAgICAgICAgIGluZGljYXRvcnMuTUEucGVyaW9kcy5mb3JFYWNoKChwZXJpb2QsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hRGF0YSA9IGNhbGN1bGF0ZU1BKGhpc3RvcmljYWxEYXRhLCBwZXJpb2QpO1xuICAgICAgICAgICAgICAgICAgICBtYVNlcmllc1JlZnMuY3VycmVudFtpbmRleF0/LnNldERhdGEobWFEYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dCb2xsaW5nZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2xsaW5nZXJEYXRhID0gY2FsY3VsYXRlQm9sbGluZ2VyQmFuZHMoXG4gICAgICAgICAgICAgICAgICAgIGhpc3RvcmljYWxEYXRhLFxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JzLkJvbGxpbmdlci5wZXJpb2QsXG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvcnMuQm9sbGluZ2VyLnN0ZERldlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYm9sbGluZ2VyU2VyaWVzUmVmcy5jdXJyZW50LnVwcGVyPy5zZXREYXRhKGJvbGxpbmdlckRhdGEudXBwZXIpO1xuICAgICAgICAgICAgICAgIGJvbGxpbmdlclNlcmllc1JlZnMuY3VycmVudC5taWRkbGU/LnNldERhdGEoYm9sbGluZ2VyRGF0YS5taWRkbGUpO1xuICAgICAgICAgICAgICAgIGJvbGxpbmdlclNlcmllc1JlZnMuY3VycmVudC5sb3dlcj8uc2V0RGF0YShib2xsaW5nZXJEYXRhLmxvd2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwMDApOyAvLyBNaXNlIMOgIGpvdXIgdG91dGVzIGxlcyAxMCBzZWNvbmRlc1xuICAgICAgICBjb25zb2xlLmxvZyhcImFmdGVyXCIsIGNyeXB0bylcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgfTtcblxuXG5cblxuXG5cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBcbiAgICAgICAgaWYgKCFjaGFydENvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgY2hhcnRPcHRpb25zID0ge1xuICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHsgdHlwZTogJ3NvbGlkJywgY29sb3I6ICd3aGl0ZScgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWlnaHQ6IDUwMCxcbiAgICAgICAgICAgIHdhdGVybWFyazoge1xuICAgICAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjaGFydCA9IGNyZWF0ZUNoYXJ0KGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQsIGNoYXJ0T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzID0gY2hhcnQuYWRkQ2FuZGxlc3RpY2tTZXJpZXMoe1xuICAgICAgICAgICAgdXBDb2xvcjogJyMyNmE2OWEnLFxuICAgICAgICAgICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICAgICAgICBib3JkZXJWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgd2lja1VwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICAgICAgICAgIHdpY2tEb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2hhcnRSZWYuY3VycmVudCA9IGNoYXJ0O1xuICAgICAgICBzZXJpZXNSZWYuY3VycmVudCA9IGNhbmRsZXN0aWNrU2VyaWVzO1xuXG4gICAgICAgIC8vIEluaXRpYWxpc2VyIGxlcyBzw6lyaWVzIE1BXG4gICAgICAgIG1hU2VyaWVzUmVmcy5jdXJyZW50ID0gaW5kaWNhdG9ycy5NQS5wZXJpb2RzLm1hcCgocGVyaW9kLCBpbmRleCkgPT5cbiAgICAgICAgICAgIGNoYXJ0LmFkZExpbmVTZXJpZXMoe1xuICAgICAgICAgICAgICAgIGNvbG9yOiBpbmRpY2F0b3JzLk1BLmNvbG9yc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IHNob3dNQSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGlzZXIgbGVzIHPDqXJpZXMgQm9sbGluZ2VyXG4gICAgICAgIGNvbnN0IGJvbGxpbmdlclVwcGVyID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XG4gICAgICAgICAgICBjb2xvcjogaW5kaWNhdG9ycy5Cb2xsaW5nZXIuY29sb3IsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgICAgICBsaW5lU3R5bGU6IDIsXG4gICAgICAgICAgICB2aXNpYmxlOiBzaG93Qm9sbGluZ2VyLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYm9sbGluZ2VyTWlkZGxlID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XG4gICAgICAgICAgICBjb2xvcjogaW5kaWNhdG9ycy5Cb2xsaW5nZXIuY29sb3IsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICB2aXNpYmxlOiBzaG93Qm9sbGluZ2VyLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYm9sbGluZ2VyTG93ZXIgPSBjaGFydC5hZGRMaW5lU2VyaWVzKHtcbiAgICAgICAgICAgIGNvbG9yOiBpbmRpY2F0b3JzLkJvbGxpbmdlci5jb2xvcixcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIGxpbmVTdHlsZTogMixcbiAgICAgICAgICAgIHZpc2libGU6IHNob3dCb2xsaW5nZXIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJvbGxpbmdlclNlcmllc1JlZnMuY3VycmVudCA9IHtcbiAgICAgICAgICAgIHVwcGVyOiBib2xsaW5nZXJVcHBlcixcbiAgICAgICAgICAgIG1pZGRsZTogYm9sbGluZ2VyTWlkZGxlLFxuICAgICAgICAgICAgbG93ZXI6IGJvbGxpbmdlckxvd2VyLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjaGFydC5yZW1vdmUoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbc3ltYm9sXSk7XG5cblxuXG5cblxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgXG4gICAgICAgIGlmICghY2hhcnRSZWYuY3VycmVudCB8fCAhc2VyaWVzUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgaW5pdGlhbGl6ZUNoYXJ0KHN5bWJvbCk7XG4gICAgfSwgW3NlbGVjdGVkVGltZWZyYW1lLCBzaG93TUEsIHNob3dCb2xsaW5nZXIsc3ltYm9sXSk7XG5cbiAgICAvLyBHw6lyZXIgbGEgdmlzaWJpbGl0w6kgZGVzIE1BXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbWFTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgICAgICAgc2VyaWVzPy5hcHBseU9wdGlvbnMoeyB2aXNpYmxlOiBzaG93TUEgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtzaG93TUFdKTtcblxuICAgIC8vIEfDqXJlciBsYSB2aXNpYmlsaXTDqSBkZXMgQm9sbGluZ2VyIEJhbmRzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhib2xsaW5nZXJTZXJpZXNSZWZzLmN1cnJlbnQpLmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgICAgIHNlcmllcz8uYXBwbHlPcHRpb25zKHsgdmlzaWJsZTogc2hvd0JvbGxpbmdlciB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW3Nob3dCb2xsaW5nZXIsIHN5bWJvbF0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlcy5jb250cm9sc0NvbnRhaW5lcn0+XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17c3R5bGVzLnRpbWVmcmFtZUNvbnRhaW5lcn0+XG4gICAgICAgICAgICAgICAgICAgIHtPYmplY3Qua2V5cyh0aW1lZnJhbWVzKS5tYXAoKHRmLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3R5bGVzLmJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBzZWxlY3RlZFRpbWVmcmFtZSA9PT0gdGYgPyAnI2RkZCcgOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZFRpbWVmcmFtZSh0ZiBhcyAnMW0nIHwgJzVtJyB8ICcxNW0nIHwgJzFoJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RmfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlcy5pbmRpY2F0b3JzQ29udGFpbmVyfT5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zdHlsZXMuYnV0dG9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogc2hvd01BID8gJyNkZGQnIDogJyNmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNob3dNQSghc2hvd01BKX1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgTUFcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3R5bGVzLmJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHNob3dCb2xsaW5nZXIgPyAnI2RkZCcgOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2hvd0JvbGxpbmdlcighc2hvd0JvbGxpbmdlcil9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIEJvbGxpbmdlclxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiByZWY9e2NoYXJ0Q29udGFpbmVyUmVmfSBzdHlsZT17eyBwb3NpdGlvbjogJ3JlbGF0aXZlJywgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnNDAwcHgnIH19IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59O1xuXG5jb25zdCBzdHlsZXM6IHsgW2tleTogc3RyaW5nXTogUmVhY3QuQ1NTUHJvcGVydGllcyB9ID0ge1xuICAgIGNvbnRyb2xzQ29udGFpbmVyOiB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogJzEwcHgnLFxuICAgIH0sXG4gICAgdGltZWZyYW1lQ29udGFpbmVyOiB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZ2FwOiAnNXB4JyxcbiAgICB9LFxuICAgIGluZGljYXRvcnNDb250YWluZXI6IHtcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBnYXA6ICc1cHgnLFxuICAgIH0sXG4gICAgYnV0dG9uOiB7XG4gICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgIGJvcmRlclJhZGl1czogJzVweCcsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjZGRkJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDaGFydENvbXBvbmVudDsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUNvbnRleHQiLCJjcmVhdGVDaGFydCIsIkNyeXB0b0NvbnRleHQiLCJ0aW1lZnJhbWVzIiwiaW5kaWNhdG9ycyIsIk1BIiwicGVyaW9kcyIsImNvbG9ycyIsIkJvbGxpbmdlciIsInBlcmlvZCIsInN0ZERldiIsImNvbG9yIiwibGF0ZXN0UHJpY2UiLCJjcnlwdG8iLCJyZXN1bHQiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwib2hsYyIsInRpbWUiLCJEYXRlIiwidGltZXN0YW1wIiwiZ2V0VGltZSIsIm5ld0NhbmRsZSIsImhpc3RvcnlQcmljZSIsInRpbWVmcmFtZSIsImhpc3RvcnkiLCJtYXAiLCJjYW5kbGUiLCJvcGVuIiwiaGlnaCIsImxvdyIsImNsb3NlIiwiY2FsY3VsYXRlTUEiLCJtYURhdGEiLCJpIiwibGVuZ3RoIiwicHVzaCIsInZhbHVlIiwiTmFOIiwic2xpY2UiLCJzdW0iLCJyZWR1Y2UiLCJhY2MiLCJjdXJyIiwibWEiLCJjYWxjdWxhdGVCb2xsaW5nZXJCYW5kcyIsInN0ZERldkZhY3RvciIsImJhbmRzIiwibWlkZGxlIiwidXBwZXIiLCJsb3dlciIsIm1lYW4iLCJ2YXJpYW5jZSIsIk1hdGgiLCJwb3ciLCJzcXJ0IiwiQ2hhcnRDb21wb25lbnQiLCJzeW1ib2wiLCJjaGFydENvbnRhaW5lclJlZiIsImNoYXJ0UmVmIiwic2VyaWVzUmVmIiwibWFTZXJpZXNSZWZzIiwiYm9sbGluZ2VyU2VyaWVzUmVmcyIsInNlbGVjdGVkVGltZWZyYW1lIiwic2V0U2VsZWN0ZWRUaW1lZnJhbWUiLCJzaG93TUEiLCJzZXRTaG93TUEiLCJzaG93Qm9sbGluZ2VyIiwic2V0U2hvd0JvbGxpbmdlciIsInVwZGF0ZUNhbmRsZSIsIm5ld1ZhbHVlIiwibWluIiwibWF4IiwiaW5pdGlhbGl6ZUNoYXJ0IiwiaGlzdG9yaWNhbERhdGEiLCJjdXJyZW50Iiwic2V0RGF0YSIsImNvbnNvbGUiLCJsb2ciLCJmb3JFYWNoIiwiaW5kZXgiLCJib2xsaW5nZXJEYXRhIiwidGltZVNjYWxlIiwiZml0Q29udGVudCIsImNvdW50IiwiY3VycmVudENyeXB0byIsImludGVydmFsSWQiLCJzZXRJbnRlcnZhbCIsImxhdGVzdENhbmRsZSIsImhpc3RvcmljYWxEYXRhMiIsImxhc3RDYW5kbGUiLCJ1cGRhdGVkQ2FuZGxlIiwidXBkYXRlIiwiZXJyb3IiLCJjbGVhckludGVydmFsIiwiY2hhcnRPcHRpb25zIiwibGF5b3V0IiwidGV4dENvbG9yIiwiYmFja2dyb3VuZCIsInR5cGUiLCJoZWlnaHQiLCJ3YXRlcm1hcmsiLCJ2aXNpYmxlIiwiY2hhcnQiLCJjYW5kbGVzdGlja1NlcmllcyIsImFkZENhbmRsZXN0aWNrU2VyaWVzIiwidXBDb2xvciIsImRvd25Db2xvciIsImJvcmRlclZpc2libGUiLCJ3aWNrVXBDb2xvciIsIndpY2tEb3duQ29sb3IiLCJhZGRMaW5lU2VyaWVzIiwibGluZVdpZHRoIiwiYm9sbGluZ2VyVXBwZXIiLCJsaW5lU3R5bGUiLCJib2xsaW5nZXJNaWRkbGUiLCJib2xsaW5nZXJMb3dlciIsInJlbW92ZSIsInNlcmllcyIsImFwcGx5T3B0aW9ucyIsIk9iamVjdCIsInZhbHVlcyIsImRpdiIsInN0eWxlIiwic3R5bGVzIiwiY29udHJvbHNDb250YWluZXIiLCJ0aW1lZnJhbWVDb250YWluZXIiLCJrZXlzIiwidGYiLCJidXR0b24iLCJiYWNrZ3JvdW5kQ29sb3IiLCJvbkNsaWNrIiwiaW5kaWNhdG9yc0NvbnRhaW5lciIsInJlZiIsInBvc2l0aW9uIiwid2lkdGgiLCJkaXNwbGF5IiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIiwibWFyZ2luQm90dG9tIiwiZ2FwIiwicGFkZGluZyIsImZvbnRXZWlnaHQiLCJjdXJzb3IiLCJib3JkZXJSYWRpdXMiLCJib3JkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/Chart.tsx\n"));

/***/ })

});